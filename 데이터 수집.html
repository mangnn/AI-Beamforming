<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>AM 빔포밍 송수신 시뮬레이터 with Heatmap</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; color:#fff; font-family:sans-serif }
    canvas.threejs { position:absolute; top:0; left:0; z-index:0 }
    #ui { position:absolute; top:10px; left:10px;
      background:rgba(255,255,255,0.9); padding:8px; border-radius:4px; color:#000;
      display:flex; gap:8px; align-items:center; z-index:20; }
    #heatmapCanvas,#maxHeatmapCanvas {
      position:absolute; right:10px; background:#fff;
      border:1px solid rgba(0,0,0,0.2); image-rendering:pixelated; z-index:10; }
    #heatmapCanvas { top:10px }
    #maxHeatmapCanvas { top:320px }
    #chart-container { position:absolute; left:10px; right:10px; bottom:10px;
      background:rgba(255,255,255,0.9); padding:12px; border-radius:4px; color:#000;
      display:flex; gap:12px; overflow-x:auto; z-index:20; }
    .receiver-chart { display:flex; flex-direction:column; flex:none; }
    .receiver-chart canvas { height:100px!important; margin-bottom:4px }
    .angle-label { font-weight:bold; color:#000; margin-bottom:4px; }
    .receiver-chart pre { width:100%; font-family:monospace; background:#fff; color:#000;
      text-align:right; padding:4px; margin:2px 0; box-sizing:border-box; }
    #accuracyTable { width:100%; border-collapse:collapse; font-size:14px; z-index:20; }
    #accuracyTable td { border:1px solid #000; padding:4px 8px; background:#fff; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="resetBtn">Reset</button>
    <span id="statusLabel"></span>
  </div>

  <canvas id="heatmapCanvas"></canvas>
  <canvas id="maxHeatmapCanvas"></canvas>

  <div id="chart-container">
    <div class="receiver-chart">
      <canvas id="chartBeam"></canvas>
      <div class="angle-label">@<span id="beamAngleLabel"></span>°</div>
      <pre id="inBeam">Bits: </pre>
      <pre id="outBeam">Received: </pre>
      <pre id="accBeam">Accuracy: </pre>
    </div>
    <table id="accuracyTable">
      <tbody>
        <tr id="angleRow"></tr>
        <tr id="accuracyRow"></tr>
      </tbody>
    </table>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      initScene();
      initGeometry();
      animate();
    });

    // 배치 설정
    const beamAngleList = [20, 40];
    const weightListSet = [[1,2,2,1],[2,1,1,2]];

    // 비트 시퀀스
    const calibrationBits = '110';
    const testBits        = '010011';
    const bitSequence     = calibrationBits + testBits;
    const bitCount        = bitSequence.length;

    // 시뮬레이션 파라미터
    let beamAngleDeg   = beamAngleList[0];
    let beamAngleRad   = beamAngleDeg * Math.PI/180;
    const pxPerBit     = 10;
    const totalWidth   = bitCount * pxPerBit;
    const heatmapRes   = 100, heatmapDisplay = 300;
    const numAntennas  = 4, spacing = 2;
    const speed        = 2e9, v = 3e10 / speed;
    const frequency    = 2.4e9 / speed, carrierPeriod = 1 / frequency;
    const bitDuration  = 1.16e-9 * speed;
    const maxDistance  = 140, circleSegs = 256, Rdistance = 50;
    const fixedAngles  = Array.from({length:17},(_,i)=>-80 + i*10);
    const tolerance    = 0.5, receiveThreshold = 5.5;

    // 가중치 초기화
    let antennaWeights = weightListSet[0].slice();

    // 진행률 계산용 변수들
    let doneParts     = 0;
    const totalBitsAll = beamAngleList.length * weightListSet.length * bitCount;

    // Phase sequence
    const phaseSeq = [
      { amp:0.5, sign:  1 },
      { amp:1.0, sign:  1 },
      { amp:0.5, sign:  1 },
      { amp:0.5, sign: -1 },
      { amp:1.0, sign: -1 },
      { amp:0.5, sign: -1 }
    ];
    const stepPeriod = carrierPeriod / phaseSeq.length;

    // 히트맵 최대값 저장
    let maxAbs    = Array.from({length:heatmapRes}, ()=>Array(heatmapRes).fill(0));
    let maxSigned = Array.from({length:heatmapRes}, ()=>Array(heatmapRes).fill(0));

    // 전역 변수
    let scene, camera, renderer, controls, clock;
    let heatmapCtx, maxCtx;
    let antennas = [], receivers = [];
    let delays = [];
    let bitEvents = [], waves = [], tick = 0, nextTime = 0;
    let simTime = 0, isRunning = false, initialized = false;

    function polarPos(deg){
      const rad = (90-deg)*Math.PI/180;
      return { x:Math.cos(rad)*Rdistance, y:Math.sin(rad)*Rdistance };
    }
    function computeDelays(angleRad){
      const λ = v / frequency, k = 2 * Math.PI / λ;
      const raw = antennas.map(a => {
        const φ = -k * a.position.x * Math.sin(angleRad);
        return -φ / (2 * Math.PI * frequency);
      });
      const m = Math.min(...raw);
      return raw.map(d => d - m);
    }

    function initScene(){
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
      camera.position.set(0,0,100);
      camera.lookAt(0,0,0);

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(innerWidth,innerHeight);
      renderer.domElement.classList.add('threejs');
      document.body.prepend(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.05;
      clock = new THREE.Clock();

      const hc = document.getElementById('heatmapCanvas');
      hc.width = hc.height = heatmapRes;
      hc.style.width = hc.style.height = `${heatmapDisplay}px`;
      heatmapCtx = hc.getContext('2d');

      const mc = document.getElementById('maxHeatmapCanvas');
      mc.width = mc.height = heatmapRes;
      mc.style.width = mc.style.height = `${heatmapDisplay}px`;
      maxCtx = mc.getContext('2d');

      document.getElementById('beamAngleLabel').innerText = beamAngleDeg;
      document.getElementById('inBeam').innerText        = 'Bits: ' + bitSequence;
      document.querySelectorAll('.receiver-chart canvas').forEach(c=>{
        c.style.width = `${totalWidth}px`; c.width = totalWidth;
        c.style.height = '100px'; c.height = 100;
      });

      window.addEventListener('resize', ()=>{
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth,innerHeight);
      });
    }

    function initGeometry(){
      antennas = [];
      const antGeom = new THREE.CylinderGeometry(0.2,0.2,1,8);
      const antMat  = new THREE.MeshBasicMaterial({color:0xffffff});
      for(let i=0;i<numAntennas;i++){
        const ant = new THREE.Mesh(antGeom,antMat);
        ant.rotation.x = Math.PI/2;
        ant.position.set((i-(numAntennas-1)/2)*spacing,0,0);
        scene.add(ant); antennas.push(ant);
        const src = new THREE.Mesh(
          new THREE.SphereGeometry(0.5,16,16),
          new THREE.MeshBasicMaterial({color:0xffff00})
        );
        src.position.copy(ant.position);
        scene.add(src);
      }
      delays = computeDelays(beamAngleRad);

      receivers = [];
      fixedAngles.forEach(deg=>{
        const {x,y} = polarPos(deg);
        const sph = new THREE.Mesh(
          new THREE.SphereGeometry(0.6,12,12),
          new THREE.MeshBasicMaterial({color:0xff0000})
        );
        sph.position.set(x,y,0);
        scene.add(sph);
        receivers.push({ pos:new THREE.Vector3(x,y,0), hitCount:Array(bitCount).fill(0), output:Array(bitCount).fill('0') });
      });
      const {x,y} = polarPos(beamAngleDeg);
      const beamS = new THREE.Mesh(
        new THREE.SphereGeometry(0.6,12,12),
        new THREE.MeshBasicMaterial({color:0x0000ff})
      );
      beamS.position.set(x,y,0);
      beamS.renderOrder = 1;
      scene.add(beamS);
      receivers.unshift({ pos:new THREE.Vector3(x,y,0), hitCount:Array(bitCount).fill(0), output:Array(bitCount).fill('0') });
    }

    const chartBeam = new Chart(
      document.getElementById('chartBeam').getContext('2d'), {
        type: 'line',
        data: { labels: Array(bitCount).fill().map((_,i)=>String(i)), datasets: [{
            label: `@${beamAngleDeg}°`, data: Array(bitCount).fill(0),
            borderColor:'#00f', fill:false, stepped:true, pointRadius:3
        }] },
        options: { scales: { x:{ title:{ display:true, text:'Bit Index'}}, y:{ min:0, max:1, ticks:{ stepSize:1}}}, plugins:{legend:{display:false}} }
      }
    );

    function signedColor(v,vmax){
      const a = Math.min(Math.abs(v)/vmax,1);
      return v>=0
        ? [255,Math.round(255*(1-a)),Math.round(255*(1-a))]
        : [Math.round(255*(1-a)),Math.round(255*(1-a)),255];
    }
    function maxColor(v,vmax){
      const a = Math.min(Math.abs(v)/vmax,1);
      return [255,Math.round(255*(1-a)),Math.round(255*(1-a))];
    }

    function detectReceivers(){
      receivers.forEach(r=>r.hitCount.fill(0));
      waves.forEach(ring=>{
        receivers.forEach(rec=>{
          const R = v*(simTime - ring.userData.t0);
          const d = rec.pos.distanceTo(ring.position);
          if(Math.abs(d-R)<tolerance){
            rec.hitCount[ring.userData.idx] += ring.userData.weight;
          }
        });
      });

      // Beam 업데이트
      const blue = receivers[0];
      blue.hitCount.forEach((cnt,i)=>{
        if(cnt >= receiveThreshold) blue.output[i] = '1';
      });
      chartBeam.data.datasets[0].data = blue.output.map(b=>b==='1'?1:0);
      chartBeam.update();
      document.getElementById('outBeam').innerText = 'Received: '+blue.output.join('');
      document.getElementById('accBeam').innerText = 'Accuracy: '+
        (blue.output.filter((b,i)=>b===bitSequence[i]).length/bitCount*100).toFixed(1)+'%';

      // Fixed receivers 테이블
      const ar = document.getElementById('angleRow'), cr = document.getElementById('accuracyRow');
      ar.innerHTML=''; cr.innerHTML='';
      fixedAngles.forEach((deg,i)=>{
        const tdA = document.createElement('td'); tdA.innerText = deg+'°'; ar.appendChild(tdA);
        const rec = receivers[i+1];
        rec.hitCount.forEach((cnt,j)=>{ if(cnt>=receiveThreshold) rec.output[j]='1'; });
        const match = rec.output.filter((b,j)=>b===bitSequence[j]).length;
        const tdB = document.createElement('td'); tdB.innerText = (match/bitCount*100).toFixed(1)+'%'; cr.appendChild(tdB);
      });
    }

    function drawHeatmap(){
      const size=heatmapRes, half=60, cell=(half*2)/size, vmax=8;
      const img=heatmapCtx.createImageData(size,size), img2=maxCtx.createImageData(size,size);
      for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
          const x = -half + (i+0.5)*cell;
          const y =  (j+0.5)*cell;
          let sum = 0;
          waves.forEach(ring=>{
            const R = v*(simTime-ring.userData.t0);
            const d = Math.hypot(x-ring.position.x, y-ring.position.y);
            if(Math.abs(d-R)<0.1) sum += ring.userData.weight * (ring.userData.sign||1);
          });
          const absS = Math.abs(sum);
          maxAbs[i][j]    = Math.max(maxAbs[i][j], absS);
          if(absS > Math.abs(maxSigned[i][j])) maxSigned[i][j] = sum;
          const row = size-1-j, idx = 4*(row*size+i);
          const [r,g,b]    = signedColor(sum, vmax);
          const [r2,g2,b2] = maxColor(maxSigned[i][j], vmax);
          img.data[idx]=r; img.data[idx+1]=g; img.data[idx+2]=b; img.data[idx+3]=255;
          img2.data[idx]=r2;img2.data[idx+1]=g2;img2.data[idx+2]=b2;img2.data[idx+3]=255;
        }
      }
      heatmapCtx.putImageData(img,0,0);
      maxCtx.putImageData(img2,0,0);
    }

    function spawnWave(ant,idx,antIdx,sign,amp=1){
      const color=amp===1?(sign>0?0xff0000:0x0088ff):(sign>0?0xffcccc:0xccccff);
      const opacity=amp===1?1:0.5;
      const pts=[]; for(let i=0;i<circleSegs;i++){ const t=i/circleSegs*2*Math.PI; pts.push(new THREE.Vector3(Math.cos(t),Math.sin(t),0)); }
      const geom=new THREE.BufferGeometry().setFromPoints(pts);
      const mat=new THREE.LineBasicMaterial({color,transparent:true,opacity});
      const loop=new THREE.LineLoop(geom,mat); loop.position.copy(ant.position);
      loop.userData={ t0:simTime, idx, weight:antennaWeights[antIdx]*amp, sign };
      scene.add(loop); waves.push(loop);
    }

    function initSim(){
      simTime=0; bitEvents=[]; waves=[]; tick=0; nextTime=0; initialized=true;
      maxAbs=Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));
      maxSigned=Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));
      receivers.forEach(r=>{ r.hitCount.fill(0); r.output.fill('0'); });
      chartBeam.data.datasets[0].data.fill(0); chartBeam.update();
      document.getElementById('statusLabel').innerText='';
    }

    function startSim(){ if(!initialized) initSim(); isRunning=true; }
    function stop(){ isRunning=false; }
    function reset(){ stop(); initialized=false; waves.forEach(w=>scene.remove(w)); initSim(); }

    function animate(){
      requestAnimationFrame(animate); controls.update();
      const dt=clock.getDelta(); if(isRunning) simTime+=dt;
      
      // 비트 이벤트 생성 & 진행률 업데이트
      while(simTime>=nextTime && tick<bitCount){
        bitEvents.push({
          time: nextTime,
          bit:  bitSequence[tick],
          idx:  tick,
          nextEmit:    Array(numAntennas).fill(nextTime),
          phaseIndex:  Array(numAntennas).fill(0),       // <- 초기화
          emittedCount:Array(numAntennas).fill(0)
        });
        nextTime+=bitDuration;
        tick++;

        const executedBits = doneParts*bitCount + tick;
        const pct = (executedBits/totalBitsAll*100).toFixed(1);
        document.getElementById('statusLabel').innerText = `실행중… ${pct}%`;
      }
      
      bitEvents.forEach(ev=>{ if(ev.bit!=='1') return; antennas.forEach((ant,j)=>{
          const startT=ev.time+delays[j], endT=ev.time+bitDuration+delays[j];
          if(ev.nextEmit[j]<startT){ ev.nextEmit[j]=startT; ev.phaseIndex[j]=0; }
          while(isRunning && ev.nextEmit[j]<=endT && ev.nextEmit[j]<=simTime){
            const {amp,sign}=phaseSeq[ev.phaseIndex[j]];
            spawnWave(ant,ev.idx,j,sign,amp);
            ev.nextEmit[j]+=stepPeriod;
            ev.phaseIndex[j]=(ev.phaseIndex[j]+1)%phaseSeq.length;
          }
      }); });
      bitEvents=bitEvents.filter(ev=>ev.bit==='1' && ev.nextEmit.some(t=>t<=ev.time+bitDuration));
      detectReceivers(); drawHeatmap();
      waves=waves.filter(w=>{ const R=v*(simTime-w.userData.t0); w.scale.set(R,R,1); if(R>maxDistance){ scene.remove(w); return false;} return true; });
      renderer.render(scene,camera);
    }

    async function runBatchSimulation(){
      doneParts = 0;
      const results=[];
      for(const angle of beamAngleList){
        for(const weights of weightListSet){
          beamAngleDeg=angle; beamAngleRad=angle*Math.PI/180;
          antennaWeights=weights.slice();
          document.getElementById('beamAngleLabel').innerText=angle;
          delays=computeDelays(beamAngleRad);
          const pos=polarPos(angle);
          receivers[0].pos.set(pos.x,pos.y,0);
          chartBeam.data.datasets[0].label=`@${angle}°`;
          chartBeam.update();

          reset(); await new Promise(r=>setTimeout(r,100));
          startSim();
          await new Promise(res=>{
            const chk=setInterval(()=>{
              if(tick>=bitCount && waves.length===0){
                clearInterval(chk);
                stop();
                detectReceivers();
                res();
              }
            },50);
          });

          const heat2D = maxAbs.map(r=>r.slice());
          const acc    = fixedAngles.map((_,i)=>{
            const rec = receivers[i+1];
            return parseFloat((rec.output.filter((b,j)=>b===bitSequence[j]).length/bitCount*100).toFixed(1));
          });
          results.push({angle, weights, maxIntensity:heat2D, accuracy:acc});
          doneParts++;
        }
      }

      // CSV 생성
      const csvLines = ['Angle,Weights,MaxIntensity,Accuracy'];
      results.forEach(r=>{
        const wEsc  = JSON.stringify(r.weights).replace(/"/g,'""');
        const miEsc = JSON.stringify(r.maxIntensity).replace(/"/g,'""');
        const acEsc = JSON.stringify(r.accuracy).replace(/"/g,'""');
        csvLines.push(`${r.angle},"${wEsc}","${miEsc}","${acEsc}"`);
      });
      const blob = new Blob([csvLines.join('\n')], { type: 'text/csv' });
      const url  = URL.createObjectURL(blob);
      const a    = document.createElement('a');
      a.href     = url;
      a.download = 'beamforming_results.csv';
      a.click();
      URL.revokeObjectURL(url);

      document.getElementById('statusLabel').innerText = '완료';
    }

    // 바인딩
    document.getElementById('startBtn').onclick = runBatchSimulation;
    document.getElementById('stopBtn').onclick  = stop;
    document.getElementById('resetBtn').onclick = reset;
    window.addEventListener('resize',()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });
  </script>
</body>
</html>
