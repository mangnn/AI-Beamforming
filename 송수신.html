<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>AM 빔포밍 송수신 시뮬레이터 with Heatmap</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: sans-serif;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 8px;
      border-radius: 4px;
      color: #000;
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    #ui button {
      padding: 4px 8px;
    }
    #heatmapCanvas,
    #maxHeatmapCanvas {
      position: absolute;
      right: 10px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      background-color: #fff;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #heatmapCanvas { top: 10px; }
    #maxHeatmapCanvas { top: 320px; }

    /* 차트 + 테이블 컨테이너 */
    #chart-container {
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;
      background: rgba(255,255,255,0.9);
      padding: 12px;
      border-radius: 4px;
      color: #000;
      display: flex;
      flex-direction: row;
      gap: 12px;
      z-index: 9;
      overflow-x: auto;
    }

    .receiver-chart {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      flex: none;
    }
    .receiver-chart canvas {
      height: 100px !important;
      margin-bottom: 4px;
    }
    .angle-label {
      font-weight: bold;
      margin-bottom: 4px;
      color: #000;
    }
    /* Bits/Received 오른쪽 정렬 */
    .receiver-chart pre {
      display: block;
      width: 100%;
      font-family: monospace;
      background: #fff;
      color: #000;
      margin: 2px 0;
      white-space: pre;
      overflow: visible;
      text-align: right;
      padding: 4px;
      box-sizing: border-box;
    }

    /* 테이블 스타일 */
    #accuracyTable {
      width: 100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    #accuracyTable td {
      border: 1px solid #000;
      padding: 4px 8px;
      text-align: center;
      background: #fff;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="resetBtn">Reset</button>
  </div>

  <canvas id="heatmapCanvas"></canvas>
  <canvas id="maxHeatmapCanvas"></canvas>

  <div id="chart-container">
    <div class="receiver-chart">
      <canvas id="chartBeam"></canvas>
      <div class="angle-label">@<span id="beamAngleLabel"></span>°</div>
      <pre id="inBeam">Bits: </pre>
      <pre id="outBeam">Received: </pre>
      <pre id="accBeam">Accuracy: </pre>
    </div>
    <table id="accuracyTable">
      <tbody>
        <tr id="angleRow"></tr>
        <tr id="accuracyRow"></tr>
      </tbody>
    </table>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script>
    // 시뮬레이션 파라미터
    const calibrationBits  = '111110';
    const testBits         = '1011000101010111';
    const bitSequence      = calibrationBits + testBits;
    const bitCount         = bitSequence.length;
    const beamAngleDeg     = 35;
    const pxPerBit         = 10;
    const totalWidth       = bitCount * pxPerBit;

    const heatmapRes       = 200;
    const heatmapDisplay   = 300;
    const numAntennas      = 4;
    const spacing          = 2;
    const speed            = 1.5e9;
    const v                = 3e10 / speed;
    const frequency        = 443e6 / speed;
    const carrierPeriod    = 1 / frequency;
    const halfPeriod       = carrierPeriod / 2;
    const phaseOffsetFrac  = 0.25;
    const resetPhasePerBit = true;
    const bitDuration      = 1.16 / 1e9 * speed;
    const maxDistance      = 140;
    const circleSegs       = 256;
    const beamAngleRad     = beamAngleDeg * Math.PI / 180;
    const Rdistance        = 50;
    const antennaWeights   = [1, 2, 2, 1];
    const fixedAngles      = Array.from({length:17},(_,i)=>-80 + i*10);
    const tolerance        = 0.5;
    const receiveThreshold = 4;

    // DOM 초기화
    document.getElementById('beamAngleLabel').innerText = beamAngleDeg;
    document.getElementById('inBeam').innerText = 'Bits: ' + bitSequence;
    document.querySelectorAll('.receiver-chart canvas').forEach(c => {
      c.style.width  = totalWidth + 'px';
      c.width        = totalWidth;
      c.style.height = '100px';
      c.height       = 100;
    });

    // Three.js 세팅
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,0,100);
    camera.lookAt(0,0,0);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    const clock = new THREE.Clock();

    // Heatmap 캔버스
    const heatmapCanvas = document.getElementById('heatmapCanvas');
    heatmapCanvas.width  = heatmapRes;
    heatmapCanvas.height = heatmapRes;
    heatmapCanvas.style.width  = heatmapDisplay + 'px';
    heatmapCanvas.style.height = heatmapDisplay + 'px';
    const heatmapCtx = heatmapCanvas.getContext('2d');

    const maxCanvas = document.getElementById('maxHeatmapCanvas');
    maxCanvas.width  = heatmapRes;
    maxCanvas.height = heatmapRes;
    maxCanvas.style.width  = heatmapDisplay + 'px';
    maxCanvas.style.height = heatmapDisplay + 'px';
    const maxCtx = maxCanvas.getContext('2d');

    let simTime     = 0;
    let isRunning   = false;
    let initialized = false;
    let bitEvents   = [];
    let waves       = [];
    let tick        = 0;
    let nextTime    = 0;

    // 안테나 생성
    const antennas = [];
    const antGeom  = new THREE.CylinderGeometry(0.2,0.2,1,8);
    const antMat   = new THREE.MeshBasicMaterial({color:0xffffff});
    for(let i=0;i<numAntennas;i++){
      const ant = new THREE.Mesh(antGeom, antMat);
      ant.rotation.x = Math.PI/2;
      ant.position.set((i-(numAntennas-1)/2)*spacing,0,0);
      scene.add(ant);
      antennas.push(ant);
      const src = new THREE.Mesh(
        new THREE.SphereGeometry(0.5,16,16),
        new THREE.MeshBasicMaterial({color:0xffff00})
      );
      src.position.copy(ant.position);
      scene.add(src);
    }

    function polarPos(deg){
      const rad = (90-deg)*Math.PI/180;
      return { x: Math.cos(rad)*Rdistance, y: Math.sin(rad)*Rdistance };
    }

    // 지연 시간 계산
    const delays = (() => {
      const λ = v / frequency;
      const k = 2 * Math.PI / λ;
      const raw = antennas.map(a => {
        const φ = -k * a.position.x * Math.sin(beamAngleRad);
        return -φ / (2 * Math.PI * frequency);
      });
      const m = Math.min(...raw);
      return raw.map(d => d - m);
    })();

    // 수신기 생성 (빨강 fixed 17개 + 파랑 beam 1개)
    const receivers = [];
    fixedAngles.forEach(deg => {
      const {x,y} = polarPos(deg);
      const sph = new THREE.Mesh(
        new THREE.SphereGeometry(0.6,12,12),
        new THREE.MeshBasicMaterial({color:0xff0000})
      );
      sph.position.set(x,y,0);
      scene.add(sph);
      receivers.push({
        pos: new THREE.Vector3(x,y,0),
        received: Array(bitCount).fill(false),
        strength: Array(bitCount).fill(0),
        output:   Array(bitCount).fill('0')
      });
    });
    { // 파랑 beam
      const {x,y} = polarPos(beamAngleDeg);
      const sph = new THREE.Mesh(
        new THREE.SphereGeometry(0.6,12,12),
        new THREE.MeshBasicMaterial({color:0x0000ff})
      );
      sph.position.set(x,y,0);
      sph.renderOrder = 1;
      scene.add(sph);
      receivers.unshift({
        pos: new THREE.Vector3(x,y,0),
        received: Array(bitCount).fill(false),
        strength: Array(bitCount).fill(0),
        output:   Array(bitCount).fill('0')
      });
    }

    // Chart.js 설정
    const chartBeam = new Chart(
      document.getElementById('chartBeam').getContext('2d'), {
        type: 'line',
        data: {
          labels: Array(bitCount).fill().map((_,i)=>String(i)),
          datasets: [{
            label: `@${beamAngleDeg}°`,
            data: Array(bitCount).fill(0),
            borderColor: '#00f',
            fill: false,
            stepped: true,
            pointRadius: 3
          }]
        },
        options: {
          scales: {
            x: { title: { display: true, text: 'Bit Index' } },
            y: { min:0, max:1, ticks:{ stepSize:1 } }
          },
          plugins:{ legend:{ display:false } }
        }
      }
    );

    // 수신 감지 + UI 업데이트
    function detectReceivers() {
      receivers.forEach(r=> r.hitCount = Array(bitCount).fill(0));
      waves.forEach(ring => receivers.forEach(rec => {
        const R = v * (simTime - ring.userData.t0);
        const d = rec.pos.distanceTo(ring.position);
        if(Math.abs(d-R) < tolerance) rec.hitCount[ring.userData.idx]++;
      }));
      receivers.forEach(rec => rec.hitCount.forEach((c,i)=>{
        if(c>=receiveThreshold && rec.output[i]==='0') rec.output[i]='1';
      }));

      // 파랑 beam 차트 & 텍스트
      const blueRec = receivers[0];
      const blueData = blueRec.output.map(b=>b==='1'?1:0);
      chartBeam.data.datasets[0].data = blueData;
      chartBeam.update();
      document.getElementById('outBeam').innerText = 'Received: ' + blueRec.output.join('');
      document.getElementById('accBeam').innerText = 'Accuracy: ' +
        (blueRec.output.filter((b,i)=>b===bitSequence[i]).length/bitCount*100).toFixed(1) + '%';

      // 테이블 업데이트 (1행: 각도, 2행: 정확도)
      const angleRow    = document.getElementById('angleRow');
      const accuracyRow = document.getElementById('accuracyRow');
      angleRow.innerHTML = '';
      accuracyRow.innerHTML = '';
      fixedAngles.forEach((deg,i)=>{
        const tdA = document.createElement('td');
        tdA.innerText = deg + '°';
        angleRow.appendChild(tdA);

        const rec = receivers[i+1];
        const match = rec.output.filter((b,j)=>b===bitSequence[j]).length;
        const tdB = document.createElement('td');
        tdB.innerText = (match/bitCount*100).toFixed(1) + '%';
        accuracyRow.appendChild(tdB);
      });
    }

    // heatmap 그리기
    function signedColor(v,vmax){
      const a = Math.min(Math.abs(v)/vmax,1);
      return v>=0
        ? [255,Math.round(255*(1-a)),Math.round(255*(1-a))]
        : [Math.round(255*(1-a)),Math.round(255*(1-a)),255];
    }
    function maxColor(v,vmax){
      const a = Math.min(Math.abs(v)/vmax,1);
      return [255,Math.round(255*(1-a)),Math.round(255*(1-a))];
    }
    let maxAbs    = Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));
    let maxSigned = Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));

    function drawHeatmap(){
      const size = heatmapRes;
      const img  = heatmapCtx.createImageData(size,size);
      const img2 = maxCtx.createImageData(size,size);
      const half = 60, cell = (half*2)/size, vmax = 8;
      for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
          const x = -half + (i+0.5)*cell;
          const y =  (j+0.5)*cell;
          let sum = 0;
          waves.forEach(ring=>{
            const R = v*(simTime-ring.userData.t0);
            const d = Math.hypot(x-ring.position.x, y-ring.position.y);
            if(Math.abs(d-R)<0.1) sum += ring.userData.weight*ring.userData.sign;
          });
          const absS = Math.abs(sum);
          maxAbs[i][j] = Math.max(maxAbs[i][j], absS);
          if(absS > Math.abs(maxSigned[i][j])) maxSigned[i][j]=sum;
          const row = size-1-j, idx = 4*(row*size+i);
          const [r,g,b]   = signedColor(sum, vmax);
          const [r2,g2,b2]= maxColor(maxSigned[i][j], vmax);
          img.data[idx]=r; img.data[idx+1]=g; img.data[idx+2]=b; img.data[idx+3]=255;
          img2.data[idx]=r2;img2.data[idx+1]=g2;img2.data[idx+2]=b2;img2.data[idx+3]=255;
        }
      }
      heatmapCtx.putImageData(img,  0,0);
      maxCtx.putImageData(img2, 0,0);
    }

    // 시뮬레이션 초기화
    function initSim(){
      simTime=0; bitEvents=[]; waves=[]; tick=0; nextTime=0; initialized=true;
      maxAbs    = Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));
      maxSigned = Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));
      receivers.forEach(r=>{ r.received.fill(false); r.output.fill('0'); });
      chartBeam.data.datasets[0].data.fill(0);
      chartBeam.update();
      document.getElementById('outBeam').innerText = 'Received:' + '0'.repeat(bitCount);
      document.getElementById('accBeam').innerText = 'Accuracy: 0%';
    }
    function start() { if(!initialized) initSim(); isRunning=true; }
    function stop()  { isRunning=false; }
    function reset() {
      isRunning=false;
      initialized=false;
      waves.forEach(w=>scene.remove(w));
      initSim();
    }

    // 애니메이션 루프
    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      const dt = clock.getDelta();
      if(isRunning) simTime += dt;

      // 비트 이벤트 생성
      while(simTime >= nextTime && tick < bitCount){
        bitEvents.push({
          time: nextTime,
          bit: bitSequence[tick],
          idx: tick,
          nextEmit: Array(numAntennas).fill(nextTime),
          phaseSign: Array(numAntennas).fill(1),
          emittedCount: Array(numAntennas).fill(0)
        });
        nextTime += bitDuration;
        tick++;
      }

      // 파동 방출
      bitEvents.forEach(ev=>{
        if(ev.bit !== '1') return;
        antennas.forEach((ant,j)=>{
          const startT = ev.time + delays[j];
          const endT   = ev.time + bitDuration + delays[j];
          if(resetPhasePerBit && ev.emittedCount[j]===0){
            ev.nextEmit[j] = startT + phaseOffsetFrac*carrierPeriod;
            ev.phaseSign[j] = 1;
          } else if(ev.nextEmit[j] < startT){
            ev.nextEmit[j] = startT;
          }
          while(isRunning && ev.nextEmit[j] <= endT && ev.nextEmit[j] <= simTime){
            spawnWave(ant, ev.idx, j, ev.phaseSign[j]);
            ev.phaseSign[j] *= -1;
            ev.nextEmit[j] += halfPeriod;
            ev.emittedCount[j]++;
          }
        });
      });
      // 완료된 이벤트 제거
      bitEvents = bitEvents.filter(ev=>{
        if(ev.bit !== '1') return false;
        const endT = ev.time + bitDuration + Math.max(...delays);
        return ev.nextEmit.some(t=>t <= endT);
      });

      detectReceivers();
      drawHeatmap();

      // 오래된 파동 제거
      waves = waves.filter(w=>{
        const R = v * (simTime - w.userData.t0);
        w.scale.set(R,R,1);
        if(R > maxDistance){
          scene.remove(w);
          return false;
        }
        return true;
      });

      renderer.render(scene, camera);
    }

    // 파동 생성 함수
    function spawnWave(ant, idx, antIdx, sign){
      const pts = [];
      for(let i=0;i<circleSegs;i++){
        const t = i/circleSegs*2*Math.PI;
        pts.push(new THREE.Vector3(Math.cos(t),Math.sin(t),0));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const mat  = new THREE.LineBasicMaterial({
        color: sign>0?0xff0000:0x0088ff,
        transparent: true,
        opacity: 0.8
      });
      const loop = new THREE.LineLoop(geom, mat);
      loop.position.copy(ant.position);
      loop.userData = { t0: simTime, idx, weight: antennaWeights[antIdx], sign };
      scene.add(loop);
      waves.push(loop);
    }

    // 이벤트 바인딩 & 루프 시작
    document.getElementById('startBtn').onclick = start;
    document.getElementById('stopBtn').onclick  = stop;
    document.getElementById('resetBtn').onclick = reset;
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    animate();
  </script>
</body>
</html>