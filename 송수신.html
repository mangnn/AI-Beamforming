<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>AM 빔포밍 송수신 시뮬레이터 with Heatmap</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: #fff;
      font-family: sans-serif;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 8px;
      border-radius: 4px;
      color: #000;
      display: flex;
      gap: 8px;
      z-index: 10;
    }
    #ui button { padding: 4px 8px; }
    #heatmapCanvas,
    #maxHeatmapCanvas {
      position: absolute;
      right: 10px;
      border: 1px solid rgba(255,255,255,0.5);
      background: #fff;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #heatmapCanvas { top: 10px; }
    #maxHeatmapCanvas { top: 320px; }
    #chart-container {
      position: absolute;
      left: 10px; right: 10px; bottom: 10px;
      background: rgba(255,255,255,0.9);
      padding: 12px; border-radius: 4px;
      color: #000; display: flex; gap: 12px;
      overflow-x: auto; z-index: 9;
    }
    .receiver-chart {
      display: flex; flex-direction: column; align-items: flex-start;
      flex: none;
    }
    .receiver-chart canvas {
      height: 100px !important; margin-bottom: 4px;
    }
    .angle-label {
      font-weight: bold; margin-bottom: 4px; color: #000;
    }
    .receiver-chart pre {
      display: block; width: 100%; font-family: monospace;
      background: #fff; color: #000; margin: 2px 0;
      white-space: pre; overflow: visible; text-align: right;
      padding: 4px; box-sizing: border-box;
    }
    #accuracyTable {
      width: 100%; border-collapse: collapse; font-size: 14px;
    }
    #accuracyTable td {
      border: 1px solid #000; padding: 4px 8px;
      text-align: center; background: #fff;
    }
  </style>
</head>
<body>
  <div id="ui">
    <button id="startBtn">Start</button>
    <button id="stopBtn">Stop</button>
    <button id="resetBtn">Reset</button>
  </div>
  <canvas id="heatmapCanvas"></canvas>
  <canvas id="maxHeatmapCanvas"></canvas>
  <div id="chart-container">
    <div class="receiver-chart">
      <canvas id="chartBeam"></canvas>
      <div class="angle-label">@<span id="beamAngleLabel"></span>°</div>
      <pre id="inBeam">Bits: </pre>
      <pre id="outBeam">Received: </pre>
      <pre id="accBeam">Accuracy: </pre>
    </div>
    <table id="accuracyTable">
      <tbody>
        <tr id="angleRow"></tr>
        <tr id="accuracyRow"></tr>
      </tbody>
    </table>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
  <script>
    // 기본 파라미터
    const calibrationBits = '111110';
    const testBits        = '1011000101010111';
    const bitSequence     = calibrationBits + testBits;
    const bitCount        = bitSequence.length;
    const beamAngleDeg    = 20;
    const pxPerBit        = 10;
    const totalWidth      = bitCount * pxPerBit;

    const heatmapRes     = 100;
    const heatmapDisplay = 300;
    const numAntennas    = 4;
    const spacing        = 2;
    const speed          = 3e9;
    const v              = 3e10 / speed;
    const frequency      = 2.4e9 / speed;
    const carrierPeriod  = 1 / frequency;
    const bitDuration    = 1.16 / 1e9 * speed;
    const maxDistance    = 140;
    const circleSegs     = 256;
    const beamAngleRad   = beamAngleDeg * Math.PI / 180;
    const Rdistance      = 50;
    const antennaWeights = [1,2,2,1];
    const fixedAngles    = Array.from({length:17},(_,i)=>-80 + i*10);
    const tolerance      = 0.5;
    const receiveThreshold = 4.5;

    // 6단계 위상 시퀀스 (맨 뒤가 중복되지 않도록)
    const phaseSeq = [
      { amp: 0.5, sign:  1 },  // 연한 빨강
      { amp: 1,   sign:  1 },  // 빨강
      { amp: 0.5, sign:  1 },  // 연한 빨강
      { amp: 0.5, sign: -1 },  // 연한 파랑
      { amp: 1,   sign: -1 },  // 파랑
      { amp: 0.5, sign: -1 }   // 연한 파랑
    ];

    // 링 생성 간격: carrierPeriod를 6등분
    const stepPeriod = carrierPeriod / phaseSeq.length;

    // DOM 세팅
    document.getElementById('beamAngleLabel').innerText = beamAngleDeg;
    document.getElementById('inBeam').innerText = 'Bits: ' + bitSequence;
    document.querySelectorAll('.receiver-chart canvas').forEach(c => {
      c.style.width  = totalWidth + 'px';
      c.width        = totalWidth;
      c.style.height = '100px';
      c.height       = 100;
    });

    // Three.js 세팅
    const scene    = new THREE.Scene();
    const camera   = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0,0,100);
    camera.lookAt(0,0,0);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(innerWidth,innerHeight);
    document.body.appendChild(renderer.domElement);
    const controls = new THREE.OrbitControls(camera,renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    const clock = new THREE.Clock();

    // Heatmap 캔버스
    const heatmapCanvas = document.getElementById('heatmapCanvas');
    heatmapCanvas.width  = heatmapRes;
    heatmapCanvas.height = heatmapRes;
    heatmapCanvas.style.width  = heatmapDisplay + 'px';
    heatmapCanvas.style.height = heatmapDisplay + 'px';
    const heatmapCtx = heatmapCanvas.getContext('2d');

    const maxCanvas = document.getElementById('maxHeatmapCanvas');
    maxCanvas.width  = heatmapRes;
    maxCanvas.height = heatmapRes;
    maxCanvas.style.width  = heatmapDisplay + 'px';
    maxCanvas.style.height = heatmapDisplay + 'px';
    const maxCtx = maxCanvas.getContext('2d');

    let simTime     = 0;
    let isRunning   = false;
    let initialized = false;
    let bitEvents   = [];
    let waves       = [];
    let tick        = 0;
    let nextTime    = 0;

    // 안테나 생성
    const antennas = [];
    const antGeom  = new THREE.CylinderGeometry(0.2,0.2,1,8);
    const antMat   = new THREE.MeshBasicMaterial({color:0xffffff});
    for(let i=0;i<numAntennas;i++){
      const ant = new THREE.Mesh(antGeom,antMat);
      ant.rotation.x = Math.PI/2;
      ant.position.set((i-(numAntennas-1)/2)*spacing,0,0);
      scene.add(ant);
      antennas.push(ant);
      const src = new THREE.Mesh(
        new THREE.SphereGeometry(0.5,16,16),
        new THREE.MeshBasicMaterial({color:0xffff00})
      );
      src.position.copy(ant.position);
      scene.add(src);
    }

    function polarPos(deg){
      const rad = (90-deg)*Math.PI/180;
      return { x: Math.cos(rad)*Rdistance, y: Math.sin(rad)*Rdistance };
    }

    // 지연 계산
    const delays = (() => {
      const λ = v / frequency;
      const k = 2 * Math.PI / λ;
      const raw = antennas.map(a => {
        const φ = -k * a.position.x * Math.sin(beamAngleRad);
        return -φ / (2 * Math.PI * frequency);
      });
      const m = Math.min(...raw);
      return raw.map(d => d - m);
    })();

    // 수신기 생성
    const receivers = [];
    fixedAngles.forEach(deg => {
      const {x,y} = polarPos(deg);
      const sph = new THREE.Mesh(
        new THREE.SphereGeometry(0.6,12,12),
        new THREE.MeshBasicMaterial({color:0xff0000})
      );
      sph.position.set(x,y,0);
      scene.add(sph);
      receivers.push({
        pos: new THREE.Vector3(x,y,0),
        hitCount: Array(bitCount).fill(0),
        output:   Array(bitCount).fill('0')
      });
    });
    {
      const {x,y} = polarPos(beamAngleDeg);
      const sph = new THREE.Mesh(
        new THREE.SphereGeometry(0.6,12,12),
        new THREE.MeshBasicMaterial({color:0x0000ff})
      );
      sph.position.set(x,y,0);
      sph.renderOrder = 1;
      scene.add(sph);
      receivers.unshift({
        pos:       new THREE.Vector3(x,y,0),
        hitCount:  Array(bitCount).fill(0),
        output:    Array(bitCount).fill('0')
      });
    }

    // Chart.js 설정
    const chartBeam = new Chart(
      document.getElementById('chartBeam').getContext('2d'), {
        type: 'line',
        data: {
          labels: Array(bitCount).fill().map((_,i)=>String(i)),
          datasets: [{
            data: Array(bitCount).fill(0),
            borderColor: '#00f',
            fill: false,
            stepped: true,
            pointRadius: 3
          }]
        },
        options: {
          scales: {
            x: { title: { display:true, text:'Bit Index' } },
            y: { min:0, max:1, ticks:{ stepSize:1 } }
          },
          plugins:{ legend:{ display:false } }
        }
      }
    );

    // 수신 감지
    function detectReceivers(){
      receivers.forEach(r=> r.hitCount.fill(0));
      waves.forEach(ring=> receivers.forEach(rec=>{
        const R = v*(simTime-ring.userData.t0);
        const d = rec.pos.distanceTo(ring.position);
        if(Math.abs(d-R) < tolerance){
          rec.hitCount[ring.userData.idx] += ring.userData.weight;
        }
      }));
      // Beam 업데이트
      const blue = receivers[0];
      blue.output.forEach((_,i)=>{
        if(blue.hitCount[i] >= receiveThreshold) blue.output[i] = '1';
      });

      chartBeam.data.datasets[0].data = blue.output.map(b=>b==='1'?1:0);
      chartBeam.update();
      document.getElementById('outBeam').innerText =
        'Received: ' + blue.output.join('');
      document.getElementById('accBeam').innerText =
        'Accuracy: ' + (blue.output.filter((b,i)=>b===bitSequence[i]).length/bitCount*100).toFixed(1) + '%';

      // Red 수신기 테이블
      const angleRow    = document.getElementById('angleRow');
      const accuracyRow = document.getElementById('accuracyRow');
      angleRow.innerHTML = '';
      accuracyRow.innerHTML = '';
      fixedAngles.forEach((deg,i)=>{
        const tdA = document.createElement('td');
        tdA.innerText = deg + '°';
        angleRow.appendChild(tdA);
        const rec = receivers[i+1];
        rec.output.forEach((_,j)=>{
          if(rec.hitCount[j] >= receiveThreshold) rec.output[j] = '1';
        });
        const match = rec.output.filter((b,j)=>b===bitSequence[j]).length;
        const tdB = document.createElement('td');
        tdB.innerText = (match/bitCount*100).toFixed(1) + '%';
        accuracyRow.appendChild(tdB);
      });
    }

    // Heatmap (unchanged)
    function signedColor(v,vmax){
      const a = Math.min(Math.abs(v)/vmax,1);
      return v>=0
        ? [255,Math.round(255*(1-a)),Math.round(255*(1-a))]
        : [Math.round(255*(1-a)),Math.round(255*(1-a)),255];
    }
    function maxColor(v,vmax){
      const a = Math.min(Math.abs(v)/vmax,1);
      return [255,Math.round(255*(1-a)),Math.round(255*(1-a))];
    }
    let maxAbs    = Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));
    let maxSigned = Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));
    function drawHeatmap(){
      const size = heatmapRes;
      const img  = heatmapCtx.createImageData(size,size);
      const img2 = maxCtx.createImageData(size,size);
      const half = 60, cell = (half*2)/size, vmax = 8;
      for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
          const x = -half + (i+0.5)*cell;
          const y =  (j+0.5)*cell;
          let sum = 0;
          waves.forEach(ring=>{
            const R = v*(simTime-ring.userData.t0);
            const d = Math.hypot(x-ring.position.x, y-ring.position.y);
            if(Math.abs(d-R)<0.1) sum += ring.userData.weight * (ring.userData.sign||1);
          });
          const absS = Math.abs(sum);
          maxAbs[i][j]    = Math.max(maxAbs[i][j], absS);
          if(absS > Math.abs(maxSigned[i][j])) maxSigned[i][j] = sum;
          const row = size-1-j, idx = 4*(row*size+i);
          const [r,g,b]    = signedColor(sum, vmax);
          const [r2,g2,b2] = maxColor(maxSigned[i][j], vmax);
          img.data[idx]=r; img.data[idx+1]=g; img.data[idx+2]=b; img.data[idx+3]=255;
          img2.data[idx]=r2;img2.data[idx+1]=g2;img2.data[idx+2]=b2;img2.data[idx+3]=255;
        }
      }
      heatmapCtx.putImageData(img,  0,0);
      maxCtx.putImageData(img2, 0,0);
    }

    // 파동 생성: amp에 따라 색/opacity 조정
    function spawnWave(ant, idx, antIdx, sign, amp){
      const color = amp===1
        ? (sign>0 ? 0xff0000 : 0x0088ff)
        : (sign>0 ? 0xffcccc : 0xccccff);
      const opacity = amp===1 ? 1 : 0.5;
      const pts = [];
      for(let i=0;i<circleSegs;i++){
        const t = i/circleSegs*2*Math.PI;
        pts.push(new THREE.Vector3(Math.cos(t), Math.sin(t),0));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      const mat  = new THREE.LineBasicMaterial({color, transparent:true, opacity});
      const loop = new THREE.LineLoop(geom, mat);
      loop.position.copy(ant.position);
      loop.userData = { t0: simTime, idx, weight: antennaWeights[antIdx]*amp, sign };
      scene.add(loop);
      waves.push(loop);
    }

    // 초기화
    function initSim(){
      simTime=0; bitEvents=[]; waves=[]; tick=0; nextTime=0; initialized=true;
      maxAbs    = Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));
      maxSigned = Array.from({length:heatmapRes},()=>Array(heatmapRes).fill(0));
      receivers.forEach(r=>{
        r.hitCount.fill(0);
        r.output.fill('0');
      });
      chartBeam.data.datasets[0].data.fill(0);
      chartBeam.update();
      document.getElementById('outBeam').innerText = 'Received:'+'0'.repeat(bitCount);
      document.getElementById('accBeam').innerText = 'Accuracy: 0%';
    }

    // 애니메이션 루프
    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      const dt = clock.getDelta();
      if(isRunning) simTime += dt;

      // 비트 이벤트 생성
      while(simTime >= nextTime && tick < bitCount){
        bitEvents.push({
          time: nextTime,
          bit:  bitSequence[tick],
          idx:  tick,
          nextEmit: delays.map(d=> nextTime + d),
          phaseIndex: Array(numAntennas).fill(0)
        });
        nextTime += bitDuration;
        tick++;
      }

      // 파동 방출 (7-단계 시퀀스)
      bitEvents.forEach(ev=>{
        if(ev.bit !== '1') return;
        antennas.forEach((ant,j)=>{
          const startT = ev.time + delays[j];
          const endT   = ev.time + bitDuration + delays[j];
          while(isRunning && ev.nextEmit[j] <= endT && ev.nextEmit[j] <= simTime){
            const { amp, sign } = phaseSeq[ev.phaseIndex[j]];
            spawnWave(ant, ev.idx, j, sign, amp);
            ev.nextEmit[j]   += stepPeriod;
            ev.phaseIndex[j] = (ev.phaseIndex[j] + 1) % phaseSeq.length;
          }
        });
      });

      // 이벤트 제거
      bitEvents = bitEvents.filter(ev=>{
        if(ev.bit !== '1') return false;
        const endT = ev.time + bitDuration + Math.max(...delays);
        return ev.nextEmit.some(t=> t <= endT );
      });

      detectReceivers();
      drawHeatmap();

      // 오래된 파동 제거
      waves = waves.filter(w=>{
        const R = v*(simTime - w.userData.t0);
        w.scale.set(R,R,1);
        if(R > maxDistance){
          scene.remove(w);
          return false;
        }
        return true;
      });

      renderer.render(scene, camera);
    }

    // 버튼 바인딩
    document.getElementById('startBtn').onclick = ()=>{
      if(!initialized) initSim();
      isRunning = true;
    };
    document.getElementById('stopBtn').onclick = ()=> isRunning = false;
    document.getElementById('resetBtn').onclick = ()=>{
      isRunning = false;
      initialized = false;
      waves.forEach(w=> scene.remove(w));
      initSim();
    };
    window.addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });

    animate();
  </script>
</body>
</html>
